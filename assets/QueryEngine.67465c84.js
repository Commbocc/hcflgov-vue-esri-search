var kt=Object.defineProperty,Qt=Object.defineProperties;var Vt=Object.getOwnPropertyDescriptors;var Ue=Object.getOwnPropertySymbols;var Lt=Object.prototype.hasOwnProperty,Dt=Object.prototype.propertyIsEnumerable;var qe=(r,e,t)=>e in r?kt(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,re=(r,e)=>{for(var t in e||(e={}))Lt.call(e,t)&&qe(r,t,e[t]);if(Ue)for(var t of Ue(e))Dt.call(e,t)&&qe(r,t,e[t]);return r},Ie=(r,e)=>Qt(r,Vt(e));import{t as N,cc as Mt,cA as zt,r as v,bq as se,_ as Y,cB as pt,cb as Oe,s as R,N as Ut,cC as Fe,d as Ae,cD as qt,br as Bt,cd as Be,cE as je,cF as jt,cG as Yt,cH as Zt,c5 as gt,cI as Ht,cJ as Wt,c as pe,cK as ne,cL as Xt,cM as Jt,v as Kt,E as $,F as j,H as ge,bn as _e,ah as _t,bp as fe,aK as es,f as ts,cN as Te,bl as Ee,bi as ss,cO as is,cP as rs,cQ as be,cR as P,cS as as,cT as ns,cU as os,cV as us,cW as yt,cX as ls,ce as cs,cY as Ye,m as X,cZ as hs,c_ as ds,c$ as fs,aN as Se,d0 as ms,d1 as ps}from"./index.32114bf6.js";import{o as Ze,u as gs}from"./aaBoundingRect.5fdf91a3.js";import{v as Ne}from"./normalizeUtils.a3d136fe.js";import{e as He}from"./ItemCache.a8b4b60a.js";import{WhereClause as _s}from"./WhereClause.5e909714.js";import{s as ys,$ as It}from"./projection.ce609a7b.js";import{t as Tt}from"./json.da51edc4.js";import{t as Is}from"./QueryEngineCapabilities.650d7541.js";import{i as ve,G as $e,f as Ts,y as Es,L as Ss,C as xs,_ as Rs,t as ws,D as We}from"./featureConversionUtils.a0fa4a55.js";import{T as Fs,s as As,m as Xe,c as Je,V as bs,g as Ns,h as vs,y as $s,D as Ps,z as Cs,f as Os,d as Gs}from"./utils.97a7b6c3.js";import{t as oe}from"./OptimizedGeometry.8b0eb5ae.js";function Ge(r,e){return r?e?4:3:e?3:2}function zi(r,e,t,i,s){if(N(e)||!e.lengths.length)return null;const a=(s==null?void 0:s.originPosition)==="upperLeft"?-1:1;r.lengths.length&&(r.lengths.length=0),r.coords.length&&(r.coords.length=0);const n=r.coords,o=[],u=t?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:l,coords:c}=e,f=Ge(t,i);let m=0;for(const h of l){const d=ks(u,c,m,h,t,i,a);d&&o.push(d),m+=h*f}if(o.sort((h,d)=>{let _=a*h[2]-a*d[2];return _===0&&t&&(_=h[4]-d[4]),_}),o.length){let h=6*o[0][2];n[0]=o[0][0]/h,n[1]=o[0][1]/h,t&&(h=6*o[0][4],n[2]=h!==0?o[0][3]/h:0),(n[0]<u[0]||n[0]>u[1]||n[1]<u[2]||n[1]>u[3]||t&&(n[2]<u[4]||n[2]>u[5]))&&(n.length=0)}if(!n.length){const h=e.lengths[0]?Qs(c,0,l[0],t,i):null;if(!h)return null;n[0]=h[0],n[1]=h[1],t&&h.length>2&&(n[2]=h[2])}return r}function ks(r,e,t,i,s,a,n=1){const o=Ge(s,a);let u=t,l=t+o,c=0,f=0,m=0,h=0,d=0;for(let x=0,E=i-1;x<E;x++,u+=o,l+=o){const p=e[u],y=e[u+1],T=e[u+2],g=e[l],S=e[l+1],w=e[l+2];let F=p*S-g*y;h+=F,c+=(p+g)*F,f+=(y+S)*F,s&&(F=p*w-g*T,m+=(T+w)*F,d+=F),p<r[0]&&(r[0]=p),p>r[1]&&(r[1]=p),y<r[2]&&(r[2]=y),y>r[3]&&(r[3]=y),s&&(T<r[4]&&(r[4]=T),T>r[5]&&(r[5]=T))}if(h*n>0&&(h*=-1),d*n>0&&(d*=-1),!h)return null;const _=[c,f,.5*h];return s&&(_[3]=m,_[4]=.5*d),_}function Qs(r,e,t,i,s){const a=Ge(i,s);let n=e,o=e+a,u=0,l=0,c=0,f=0;for(let m=0,h=t-1;m<h;m++,n+=a,o+=a){const d=r[n],_=r[n+1],x=r[n+2],E=r[o],p=r[o+1],y=r[o+2],T=i?Ls(d,_,x,E,p,y):Vs(d,_,E,p);if(T)if(u+=T,i){const g=Ms(d,_,x,E,p,y);l+=T*g[0],c+=T*g[1],f+=T*g[2]}else{const g=Ds(d,_,E,p);l+=T*g[0],c+=T*g[1]}}return u>0?i?[l/u,c/u,f/u]:[l/u,c/u]:t>0?i?[r[e],r[e+1],r[e+2]]:[r[e],r[e+1]]:null}function Vs(r,e,t,i){const s=t-r,a=i-e;return Math.sqrt(s*s+a*a)}function Ls(r,e,t,i,s,a){const n=i-r,o=s-e,u=a-t;return Math.sqrt(n*n+o*o+u*u)}function Ds(r,e,t,i){return[r+.5*(t-r),e+.5*(i-e)]}function Ms(r,e,t,i,s,a){return[r+.5*(i-r),e+.5*(s-e),t+.5*(a-t)]}const xe=[0,0];function Et(r,e){if(!e)return null;if("x"in e){const t={x:0,y:0};return[t.x,t.y]=r(e.x,e.y,xe),e.z!=null&&(t.z=e.z),e.m!=null&&(t.m=e.m),t}if("xmin"in e){const t={xmin:0,ymin:0,xmax:0,ymax:0};return[t.xmin,t.ymin]=r(e.xmin,e.ymin,xe),[t.xmax,t.ymax]=r(e.xmax,e.ymax,xe),e.hasZ&&(t.zmin=e.zmin,t.zmax=e.zmax,t.hasZ=!0),e.hasM&&(t.mmin=e.mmin,t.mmax=e.mmax,t.hasM=!0),t}return"rings"in e?{rings:Ke(e.rings,r),hasM:e.hasM,hasZ:e.hasZ}:"paths"in e?{paths:Ke(e.paths,r),hasM:e.hasM,hasZ:e.hasZ}:"points"in e?{points:St(e.points,r),hasM:e.hasM,hasZ:e.hasZ}:void 0}function Ke(r,e){const t=[];for(const i of r)t.push(St(i,e));return t}function St(r,e){const t=[];for(const i of r){const s=e(i[0],i[1],[0,0]);t.push(s),i.length>2&&s.push(i[2]),i.length>3&&s.push(i[3])}return t}async function ee(r,e){if(!e)return;const t=Array.isArray(r)?r.map(i=>v(i.geometry)&&i.geometry.spatialReference):[r];await ys(t.map(i=>({source:i,dest:e})))}const xt=Et.bind(null,Mt),Rt=Et.bind(null,zt);function M(r,e,t){if(!r||(t||(t=e,e=r.spatialReference),!se(e)||!se(t)||Y(e,t)))return r;if(pt(e,t)){const i=Oe(t)?xt(r):Rt(r);return i.spatialReference=t,i}return It(Tt,[r],e,t,null)[0]}class zs{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(e,t,i){if(!e||!e.length||!t||!i||Y(t,i))return e;const s={geometries:e,inSpatialReference:t,outSpatialReference:i,resolve:null};return this._jobs.push(s),new Promise(a=>{s.resolve=a,this._timer===null&&(this._timer=setTimeout(this._process,10))})}_process(){this._timer=null;const e=this._jobs.shift();if(!e)return;const{geometries:t,inSpatialReference:i,outSpatialReference:s,resolve:a}=e;pt(i,s)?Oe(s)?a(t.map(xt)):a(t.map(Rt)):a(It(Tt,t,i,s,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const Us=new zs;function qs(r,e,t){return Us.push(r,e,t)}class Bs{constructor(e,t){this._cache=new He(e),this._invalidCache=new He(t)}get(e,t){const i=`${t.uid}:${e}`,s=this._cache.get(i);if(s)return s;if(this._invalidCache.get(i)!==void 0)return null;try{const a=_s.create(e,t);return this._cache.put(i,a),a}catch{return this._invalidCache.put(i,null),null}}}const ke=new Bs(50,500),U="feature-store:unsupported-query",wt=" as ",js=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Ys(r,e){if(!e)return!0;const t=ke.get(e,r);if(!t)throw new R(U,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new R(U,"where clause is not standard",{where:e});return D(r,t.fieldNames,"where clause contains missing fields"),!0}function Zs(r,e,t){if(!e)return!0;const i=ke.get(e,r);if(!i)throw new R(U,"invalid SQL expression",{having:e});if(!i.isAggregate)throw new R(U,"having does not contain a valid aggregate function",{having:e});const s=i.fieldNames;if(D(r,s,"having contains missing fields"),!i.getExpressions().every(a=>{const{aggregateType:n,field:o}=a,u=r.has(o)&&r.get(o).name;return t.some(l=>{const{onStatisticField:c,statisticType:f}=l;return(r.has(c)&&r.get(c).name)===u&&f.toLowerCase().trim()===n})}))throw new R(U,"expressions in having should also exist in outStatistics",{having:e});return!0}function K(r,e){return r?ke.get(r,e):null}function D(r,e,t,i=!0){const s=[];for(const a of e)if(a!=="*"&&!r.has(a))if(i){const n=Ft(a);try{const o=K(n,r);if(!o)throw new R(U,"invalid SQL expression",{where:n});if(!o.isStandardized)throw new R(U,"expression is not standard",{clause:o});D(r,o.fieldNames,"expression contains missing fields")}catch(o){const u=o&&o.details;if(u&&(u.clause||u.where))throw o;u&&u.missingFields?s.push(...u.missingFields):s.push(a)}}else s.push(a);if(s.length)throw new R(U,t,{missingFields:s})}function Ft(r){return r.split(wt)[0]}function Hs(r){return r.split(wt)[1]}function Ws(r,e){const t=e.get(r);return!!t&&!js.has(t.type)}const Qe=(r,e,t)=>[e,t],ie=(r,e,t)=>[e,t,r[2]],Ve=(r,e,t)=>[e,t,r[2],r[3]];function et(r){return r?{originPosition:r.originPosition==="upper-left"?"upperLeft":r.originPosition==="lower-left"?"lowerLeft":r.originPosition,scale:r.tolerance?[r.tolerance,r.tolerance]:[1,1],translate:v(r.extent)?[r.extent.xmin,r.extent.ymax]:[0,0]}:null}function At({scale:r,translate:e},t){return t*r[0]+e[0]}function bt({scale:r,translate:e},t){return e[1]-t*r[1]}function Nt(r,e,t){const i=new Array(t.length);if(!t.length)return i;const[s,a]=r.scale;let n=At(r,t[0][0]),o=bt(r,t[0][1]);i[0]=e(t[0],n,o);for(let u=1;u<t.length;u++){const l=t[u];n+=l[0]*s,o-=l[1]*a,i[u]=e(l,n,o)}return i}function vt(r,e,t){const i=new Array(t.length);for(let s=0;s<t.length;s++)i[s]=Nt(r,e,t[s]);return i}function Xs(r,e,t,i){return Nt(r,t?i?Ve:ie:i?ie:Qe,e)}function Js(r,e,t,i){return vt(r,t?i?Ve:ie:i?ie:Qe,e)}function Ks(r,e,t,i){return vt(r,t?i?Ve:ie:i?ie:Qe,e)}function Ui(r,e,t,i,s){return v(t)&&(e.points=Xs(r,t.points,i,s)),e}function qi(r,e,t,i,s){return N(t)||(e.x=At(r,t.x),e.y=bt(r,t.y),e!==t&&(i&&(e.z=t.z),s&&(e.m=t.m))),e}function Bi(r,e,t,i,s){return v(t)&&(e.rings=Ks(r,t.rings,i,s)),e}function ji(r,e,t,i,s){return v(t)&&(e.paths=Js(r,t.paths,i,s)),e}class ce{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&s.indexOf("*")===-1){this.outFields=s;let a=0;for(const n of s){const o=Ft(n),u=this.fieldsIndex.get(o),l=u?null:K(o,i),c=u?u.name:Hs(n)||"FIELD_EXP_"+a++;this._fieldDataCache.set(n,{alias:c,clause:l})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let a=null;return this._fieldDataCache.has(s)?a=this._fieldDataCache.get(s).clause:i||(a=K(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:a})),i?this.featureAdapter.getAttribute(e,s):a.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const i=t.normalizationType,s=t.normalizationTotal;let a=this.getFieldValue(e,t.field,t.fieldInfo);if(i&&Number.isFinite(a)){const n=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);a=Fs(a,i,n,s)}return a}getExpressionValue(e,t,i){const s={attributes:this.featureAdapter.getAttributes(e)},a=i.createExecContext(s,t.viewInfo);return i.executeFunction(t.compiledFunc,a)}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:K(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:K(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:a,clause:n}=this._fieldDataCache.get(s);i[a]=n?n.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,a)}return i}_processAttributesForDistinctValues(e){if(N(e)||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const n of t){const{alias:o}=this._fieldDataCache.get(n);i.push(e[o])}else for(const n in e)i.push(e[n]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let a=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++a),a>1?null:e}}function ei(r,e){if(!r)return null;const t=e.featureAdapter,{startTimeField:i,endTimeField:s}=r;let a=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;if(i&&s)e.forEach(o=>{const u=t.getAttribute(o,i),l=t.getAttribute(o,s);u==null||isNaN(u)||(a=Math.min(a,u)),l==null||isNaN(l)||(n=Math.max(n,l))});else{const o=i||s;e.forEach(u=>{const l=t.getAttribute(u,o);l==null||isNaN(l)||(a=Math.min(a,l),n=Math.max(n,l))})}return{start:a,end:n}}function ti(r,e,t){if(!e||!r)return null;const{startTimeField:i,endTimeField:s}=r;if(!i&&!s)return null;const{start:a,end:n}=e;return a===null&&n===null?null:a===void 0&&n===void 0?ri():i&&s?si(t,i,s,a,n):ii(t,i||s,a,n)}function si(r,e,t,i,s){return i!=null&&s!=null?a=>{const n=r.getAttribute(a,e),o=r.getAttribute(a,t);return(n==null||n<=s)&&(o==null||o>=i)}:i!=null?a=>{const n=r.getAttribute(a,t);return n==null||n>=i}:s!=null?a=>{const n=r.getAttribute(a,e);return n==null||n<=s}:void 0}function ii(r,e,t,i){return t!=null&&i!=null&&t===i?s=>r.getAttribute(s,e)===t:t!=null&&i!=null?s=>{const a=r.getAttribute(s,e);return a>=t&&a<=i}:t!=null?s=>r.getAttribute(s,e)>=t:i!=null?s=>r.getAttribute(s,e)<=i:void 0}function ri(){return()=>!1}const ai=new Ut({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),L=Object.freeze({}),tt=new oe,ni=new oe,Pe=new oe,Re={esriGeometryPoint:$e,esriGeometryPolyline:Ss,esriGeometryPolygon:xs,esriGeometryMultipoint:Rs};function st(r,e,t,i=r.hasZ,s=r.hasM){if(N(e))return null;const a=r.hasZ&&i,n=r.hasM&&s;if(t){const o=ve(Pe,e,r.hasZ,r.hasM,"esriGeometryPoint",t,i,s);return $e(o,a,n)}return $e(e,a,n)}function z(r,e,t,i,s,a,n=e,o=t){const u=e&&n,l=t&&o,c=v(i)?"coords"in i?i:i.geometry:null;if(N(c))return null;if(s){let f=Ts(ni,c,e,t,r,s,n,o);return a&&(f=ve(Pe,f,u,l,r,a)),Re[r](f,u,l)}if(a){const f=ve(Pe,c,e,t,r,a,n,o);return Re[r](f,u,l)}return Es(tt,c,e,t,n,o),Re[r](tt,u,l)}async function J(r,e,t){const{outFields:i,orderByFields:s,groupByFieldsForStatistics:a,outStatistics:n}=r;if(i)for(let o=0;o<i.length;o++)i[o]=i[o].trim();if(s)for(let o=0;o<s.length;o++)s[o]=s[o].trim();if(a)for(let o=0;o<a.length;o++)a[o]=a[o].trim();if(n)for(let o=0;o<n.length;o++)n[o].onStatisticField&&(n[o].onStatisticField=n[o].onStatisticField.trim());return r.geometry&&!r.outSR&&(r.outSR=r.geometry.spatialReference),oi(r,e,t)}async function oi(r,e,t){if(!r)return null;let{where:i}=r;if(r.where=i=i&&i.trim(),(!i||/^1 *= *1$/.test(i)||e&&e===i)&&(r.where=null),!r.geometry)return r;let s=await ui(r);if(r.distance=0,r.units=null,r.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:u}=r.geometry;s=Fe(s),s.spatialReference=u}r.geometry=s,await ee(s.spatialReference,t);const a=(await Ne(Ae(s)))[0];if(N(a))throw L;const n=a.toJSON(),o=await M(n,n.spatialReference,t);if(!o)throw L;return o.spatialReference=t,r.geometry=o,r}async function ui(r){const{geometry:e,distance:t,units:i}=r;if(t==null||"vertexAttributes"in e)return e;const s=e.spatialReference,a=i?ai.fromJSON(i):qt(s),n=s&&(Bt(s)||Oe(s))?e:await ee(s,Be).then(()=>M(e,Be));return(await li())(n.spatialReference,n,t,a)}async function li(){return(await import("./geometryEngineJSON.1eda2436.js")).geodesicBuffer}function te(r){return r&&$t in r?JSON.parse(JSON.stringify(r,ci)):r}const $t="_geVersion",ci=(r,e)=>r!==$t?e:void 0;class A{constructor(e,t,i){this.items=e,this.queryGeometry=t,this.definitionExpression=i.definitionExpression,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.fieldsIndex=i.fieldsIndex,this.timeInfo=i.timeInfo,this.featureAdapter=i.featureAdapter,this.aggregateAdapter=i.aggregateAdapter}get size(){return this.items.length}createQueryResponseForCount(e){const t=new ce(e,this.featureAdapter,this.fieldsIndex);if(!e.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:i,having:s}=e;if(!(i!=null&&i.length))return 1;const a=new Map,n=new Map,o=new Set,u=e.outStatistics;for(const l of u){const{statisticType:c}=l,f=c!=="exceedslimit"?l.onStatisticField:void 0;if(!n.has(f)){const h=[];for(const d of i){const _=this._getAttributeValues(t,d,a);h.push(_)}n.set(f,this._calculateUniqueValues(h,t.returnDistinctValues))}const m=n.get(f);for(const h in m){const{data:d,items:_}=m[h],x=d.join(",");s&&!t.validateItems(_,s)||o.add(x)}}return o.size}async createQueryResponse(e){let t;return e.outStatistics?t=e.outStatistics.some(i=>i.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(e):await this._createStatisticsQueryResponse(e):t=this._createFeatureQueryResponse(e),e.returnQueryGeometry&&(se(e.outSR)&&!Y(this.queryGeometry.spatialReference,e.outSR)?t.queryGeometry=te(re({spatialReference:e.outSR},M(this.queryGeometry,this.queryGeometry.spatialReference,e.outSR))):t.queryGeometry=te(re({spatialReference:e.outSR},this.queryGeometry))),t}createSnappingResponse(e,t){const i=this.featureAdapter,s=di(this.hasZ,this.hasM),{x:a,y:n}=e.point,o=typeof e.distance=="number"?e.distance:e.distance.x,u=typeof e.distance=="number"?e.distance:e.distance.y,l={candidates:[]},c=this.geometryType==="esriGeometryPolygon",f=this._getPointCreator(e.point,this.spatialReference,t);for(const m of this.items){const h=i.getGeometry(m);if(N(h))continue;const{coords:d,lengths:_}=h;if(e.types&ue.EDGE){let x=0;for(let E=0;E<_.length;E++){const p=_[E];for(let y=0;y<p;y++,x+=s){const T=d[x],g=d[x+1];if(y!==p-1){const S=d[x+s],w=d[x+s+1],{x:F,y:q}=hi(a,n,T,g,S,w),C=(a-F)/o,k=(n-q)/u,Z=C*C+k*k;Z<=1&&l.candidates.push({type:"edge",objectId:i.getObjectId(m),distance:Math.sqrt(Z),target:f(F,q),start:f(T,g),end:f(S,w)})}}}}if(e.types&ue.VERTEX){const x=c?d.length-s:d.length;for(let E=0;E<x;E+=s){const p=d[E],y=d[E+1],T=(a-p)/o,g=(n-y)/u,S=T*T+g*g;S<=1&&l.candidates.push({type:"vertex",objectId:i.getObjectId(m),distance:Math.sqrt(S),target:f(p,y)})}}}return l.candidates.sort((m,h)=>m.distance-h.distance),l}_getPointCreator(e,t,i){const s=v(i)&&!Y(t,i)?a=>M(a,t,i):a=>a;return e.z!=null&&e.m!=null?(a,n)=>s({x:a,y:n,z:e.z,m:e.m}):e.z!=null?(a,n)=>s({x:a,y:n,z:e.z}):e.m!=null?(a,n)=>s({x:a,y:n,m:e.m}):(a,n)=>s({x:a,y:n})}executeAttributesQuery(e){const t=K(e.where,this.fieldsIndex);if(!t)return Promise.resolve(this);if(t.isStandardized){let i=0;const s=[];for(const n of this.items)t.testFeature(n,this.featureAdapter)&&(s[i++]=n);const a=new A(s,this.queryGeometry,this);return a.definitionExpression=e.where,Promise.resolve(a)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(e){if(!e.aggregateIds||!e.aggregateIds.length||N(this.aggregateAdapter))return Promise.resolve(this);const t=new Set;for(const s of e.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach(a=>t.add(a));const i=this.featureAdapter.getObjectId;return Promise.resolve(new A(this.items.filter(s=>t.has(i(s))),this.queryGeometry,this))}executeObjectIdsQuery(e){if(!e.objectIds||!e.objectIds.length)return Promise.resolve(this);const t=new Set(e.objectIds),i=this.featureAdapter.getObjectId;return Promise.resolve(new A(this.items.filter(s=>t.has(i(s))),this.queryGeometry,this))}executeTimeQuery(e){const t=ti(this.timeInfo,e.timeExtent,this.featureAdapter);if(!v(t))return Promise.resolve(this);const i=this.items.filter(t);return Promise.resolve(new A(i,this.queryGeometry,this))}filterLatest(){const{trackIdField:e,startTimeField:t,endTimeField:i}=this.timeInfo,s=i||t,a=new Map,n=this.featureAdapter.getAttribute;for(const u of this.items){const l=n(u,e),c=n(u,s),f=a.get(l);(!f||c>n(f,s))&&a.set(l,u)}const o=Array.from(a.values());return Promise.resolve(new A(o,this.queryGeometry,this))}async project(e){if(!e||Y(this.spatialReference,e))return this;const t=this.featureAdapter,i=(await qs(this.items.map(s=>z(this.geometryType,this.hasZ,this.hasM,t.getGeometry(s))),this.spatialReference,e)).map((s,a)=>t.cloneWithGeometry(this.items[a],ws(s,this.hasZ,this.hasM)));return new A(i,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:e,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:n,normalizationTotal:o,minValue:u,maxValue:l,scale:c}=t,f=this.fieldsIndex.isDateField(i),m=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:n,normalizationTotal:o,scale:c}),h=As({normalizationType:n,normalizationField:a,minValue:u,maxValue:l}),d=this.fieldsIndex.get(i),_={value:.5,fieldType:d==null?void 0:d.type},x=je(d)?Xe({values:m,supportsNullCount:h,percentileParams:_}):Je({values:m,minValue:u,maxValue:l,useSampleStdDev:!n,supportsNullCount:h,percentileParams:_});return bs(x,f)}async createUniqueValuesResponse(e,t){const{field:i,valueExpression:s,domain:a,returnAllCodedValues:n,scale:o}=t,u=await this._getDataValues(e,{field:i,valueExpression:s,scale:o}),l=Ns(u);return vs(l,a,n)}async createClassBreaksResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:n,normalizationTotal:o,classificationMethod:u,standardDeviationInterval:l,minValue:c,maxValue:f,numClasses:m,scale:h}=t,d=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:n,normalizationTotal:o,scale:h}),_=$s(d,{field:i,normalizationField:a,normalizationType:n,normalizationTotal:o,classificationMethod:u,standardDeviationInterval:l,minValue:c,maxValue:f,numClasses:m});return Ps(_,u)}async createHistogramResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:n,normalizationTotal:o,classificationMethod:u,standardDeviationInterval:l,minValue:c,maxValue:f,numBins:m,scale:h}=t,d=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:n,normalizationTotal:o,scale:h});return Cs(d,{field:i,normalizationField:a,normalizationType:n,normalizationTotal:o,classificationMethod:u,standardDeviationInterval:l,minValue:c,maxValue:f,numBins:m})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const a=s.split(" "),n=a[0],o=this.fieldsIndex.get(n),u=a[1]&&a[1].toLowerCase()==="desc",l=Os(o==null?void 0:o.type,u);e.sort((c,f)=>{const m=i(c,n,o),h=i(f,n,o);return l(m,h)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:a,objectIdField:n,spatialReference:o}=this,{outFields:u,outSR:l,quantizationParameters:c,resultRecordCount:f,resultOffset:m,returnZ:h,returnM:d}=e,_=f!=null&&t.length>(m||0)+f,x=u&&(u.includes("*")?[...this.fieldsIndex.fields]:u.map(E=>this.fieldsIndex.get(E)));return{exceededTransferLimit:_,features:this._createFeatures(e,t),fields:x,geometryType:i,hasM:s&&d,hasZ:a&&h,objectIdFieldName:n,spatialReference:te(l||o),transform:c&&et(c)||null}}_createFeatures(e,t){const i=new ce(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:n,quantizationParameters:o,returnGeometry:u,returnCentroid:l,maxAllowableOffset:c,resultOffset:f,resultRecordCount:m,returnZ:h=!1,returnM:d=!1}=e,_=a&&h,x=s&&d;let E=[],p=0;const y=[...t];if(this._sortFeatures(y,n,(g,S,w)=>i.getFieldValue(g,S,w)),u||l){const g=et(o);if(u&&!l)for(const S of y)E[p++]={attributes:i.getAttributes(S),geometry:z(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(S),c,g,_,x)};else if(!u&&l)for(const S of y)E[p++]={attributes:i.getAttributes(S),centroid:st(this,this.featureAdapter.getCentroid(S,this),g)};else for(const S of y)E[p++]={attributes:i.getAttributes(S),centroid:st(this,this.featureAdapter.getCentroid(S,this),g),geometry:z(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(S),c,g,_,x)}}else for(const g of y){const S=i.getAttributes(g);S&&(E[p++]={attributes:S})}const T=f||0;if(m!=null){const g=T+m;E=E.slice(T,Math.min(E.length,g))}return E}_createExceedsLimitQueryResponse(e){let t=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY;for(const n of e.outStatistics)if(n.statisticType==="exceedslimit"){i=n.maxPointCount!=null?n.maxPointCount:Number.POSITIVE_INFINITY,s=n.maxRecordCount!=null?n.maxRecordCount:Number.POSITIVE_INFINITY,a=n.maxVertexCount!=null?n.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>i;else if(this.items.length>s)t=!0;else{const n=this.hasZ?this.hasM?4:3:this.hasM?3:2,o=this.featureAdapter;t=this.items.reduce((u,l)=>{const c=o.getGeometry(l);return u+(v(c)&&c.coords.length||0)},0)/n>a}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,a=new Map,n=new Map,o=new Map,u=new ce(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:c,having:f,orderByFields:m}=e,h=c&&c.length,d=!!h,_=d&&c[0],x=d&&!this.fieldsIndex.get(_);for(const p of l){const{outStatisticFieldName:y,statisticType:T}=p,g=p,S=T!=="exceedslimit"?p.onStatisticField:void 0,w=T==="percentile_disc"||T==="percentile_cont",F=T==="EnvelopeAggregate"||T==="CentroidAggregate"||T==="ConvexHullAggregate",q=d&&h===1&&(S===_||x)&&T==="count";if(d){if(!n.has(S)){const k=[];for(const Z of c){const le=this._getAttributeValues(u,Z,s);k.push(le)}n.set(S,this._calculateUniqueValues(k,u.returnDistinctValues))}const C=n.get(S);for(const k in C){const{count:Z,data:le,items:De,itemPositions:Ot}=C[k],Me=le.join(",");if(!f||u.validateItems(De,f)){const H=o.get(Me)||{attributes:{}};if(F){H.aggregateGeometries||(H.aggregateGeometries={});const{aggregateGeometries:Q,outStatisticFieldName:W}=await this._getAggregateGeometry(g,De);H.aggregateGeometries[W]=Q}else{let Q=null;if(q)Q=Z;else{const W=this._getAttributeValues(u,S,s),ze=Ot.map(Gt=>W[Gt]);Q=w&&"statisticParameters"in g?this._getPercentileValue(g,ze):this._getStatisticValue(g,ze,null,u.returnDistinctValues)}H.attributes[y]=Q}c.forEach((Q,W)=>H.attributes[this.fieldsIndex.get(Q)?Q:`EXPR_${W+1}`]=le[W]),o.set(Me,H)}}}else if(F){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:C,outStatisticFieldName:k}=await this._getAggregateGeometry(g,this.items);t.aggregateGeometries[k]=C}else{const C=this._getAttributeValues(u,S,s);t.attributes[y]=w&&"statisticParameters"in g?this._getPercentileValue(g,C):this._getStatisticValue(g,C,a,u.returnDistinctValues)}i.push({name:y,alias:y,type:"esriFieldTypeDouble"})}const E=d?Array.from(o.values()):[t];return this._sortFeatures(E,m,(p,y)=>p.attributes[y]),{fields:i,features:E}}async _getAggregateGeometry(e,t){const i=await import("./geometryEngineJSON.1eda2436.js"),{statisticType:s,outStatisticFieldName:a}=e,{featureAdapter:n,spatialReference:o,geometryType:u,hasZ:l,hasM:c}=this,f=t.map(d=>z(u,l,c,n.getGeometry(d))),m=i.convexHull(o,f,!0)[0],h={aggregateGeometries:null,outStatisticFieldName:null};if(s==="EnvelopeAggregate"){const d=m?jt(m):Fe(i.union(o,f));h.aggregateGeometries=Ie(re({},d),{spatialReference:o}),h.outStatisticFieldName=a||"extent"}else if(s==="CentroidAggregate"){const d=m?Yt(m):Zt(Fe(i.union(o,f)));h.aggregateGeometries={x:d[0],y:d[1],spatialReference:o},h.outStatisticFieldName=a||"centroid"}else s==="ConvexHullAggregate"&&(h.aggregateGeometries=m,h.outStatisticFieldName=a||"convexHull");return h}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:n}=e;let o=null;return o=i!=null&&i.has(a)?i.get(a):je(this.fieldsIndex.get(a))?Xe({values:t,returnDistinct:s}):Je({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,o),o[n==="var"?"variance":n]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:n,orderBy:o}=s,u=this.fieldsIndex.get(i),l={value:n,orderBy:o,fieldType:u==null?void 0:u.type,isDiscrete:a==="percentile_disc"};return Gs(t,l)}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),a=this.items.map(n=>e.getFieldValue(n,t,s));return i.set(t,a),a}_getAttributeNormalizedValues(e,t){return this.items.map(i=>e.getNormalizedValue(i,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await gt(),a=s.createFunction(t),n=i&&s.getViewInfo(i);return this.items.map(o=>e.getExpressionValue(o,{compiledFunc:a,viewInfo:n},s))}_calculateUniqueValues(e,t){const i={},s=this.items,a=s.length;for(let n=0;n<a;n++){const o=s[n],u=[];for(const c of e)u.push(c[n]);const l=u.join(",");t?i[l]==null&&(i[l]={count:1,data:u,items:[o],itemPositions:[n]}):i[l]==null?i[l]={count:1,data:u,items:[o],itemPositions:[n]}:(i[l].count++,i[l].items.push(o),i[l].itemPositions.push(n))}return i}async _getDataValues(e,t){const i=new ce(e,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:a,normalizationField:n,normalizationType:o,normalizationTotal:u,scale:l}=t,c=s?{viewingMode:"map",scale:l,spatialReference:e.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(i,s,c):this._getAttributeNormalizedValues(i,{field:a,normalizationField:n,normalizationType:o,normalizationTotal:u})}}function hi(r,e,t,i,s,a){const n=s-t,o=a-i,u=n*n+o*o,l=(r-t)*n+(e-i)*o,c=Math.min(1,Math.max(0,l/u));return{x:t+n*c,y:i+o*c}}function di(r,e){return r?e?4:3:e?3:2}var ue;(function(r){r[r.NONE=0]="NONE",r[r.EDGE=1]="EDGE",r[r.VERTEX=2]="VERTEX"})(ue||(ue={}));function fi(r){return r==="mesh"?Ht:Wt(r)}function Pt(r,e){return r?e?4:3:e?3:2}function mi(r,e,t,i){return Ct(r,e,t,i.coords[0],i.coords[1])}function pi(r,e,t,i,s,a){const n=Pt(s,a),{coords:o,lengths:u}=i;if(!u)return!1;for(let l=0,c=0;l<u.length;l++,c+=n)if(!Ct(r,e,t,o[c],o[c+1]))return!1;return!0}function Ct(r,e,t,i,s){if(!r)return!1;const a=Pt(e,t),{coords:n,lengths:o}=r;let u=!1,l=0;for(const c of o)u=gi(u,n,a,l,c,i,s),l+=c*a;return u}function gi(r,e,t,i,s,a,n){let o=r,u=i;for(let l=i,c=i+s*t;l<c;l+=t){u=l+t,u===c&&(u=i);const f=e[l],m=e[l+1],h=e[u],d=e[u+1];(m<n&&d>=n||d<n&&m>=n)&&f+(n-m)/(d-m)*(h-f)<a&&(o=!o)}return o}const we="feature-store:unsupported-query",_i={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},Le={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function yi(r){return Le.spatialRelationship[r]===!0}function Ii(r){return Le.queryGeometry[Kt(r)]===!0}function Ti(r){return Le.layerGeometry[r]===!0}function Ei(){return import("./geometryEngineJSON.1eda2436.js")}function it(r,e,t,i,s){if(pe(e)&&t==="esriGeometryPoint"&&(r==="esriSpatialRelIntersects"||r==="esriSpatialRelContains")){const a=We(new oe,e,!1,!1);return Promise.resolve(n=>mi(a,!1,!1,n))}if(pe(e)&&t==="esriGeometryMultipoint"){const a=We(new oe,e,!1,!1);if(r==="esriSpatialRelContains")return Promise.resolve(n=>pi(a,!1,!1,n,i,s))}if(ne(e)&&t==="esriGeometryPoint"&&(r==="esriSpatialRelIntersects"||r==="esriSpatialRelContains"))return Promise.resolve(a=>Xt(e,z(t,i,s,a)));if(ne(e)&&t==="esriGeometryMultipoint"&&r==="esriSpatialRelContains")return Promise.resolve(a=>Jt(e,z(t,i,s,a)));if(ne(e)&&r==="esriSpatialRelIntersects"){const a=fi(t);return Promise.resolve(n=>a(e,z(t,i,s,n)))}return Ei().then(a=>{const n=a[_i[r]].bind(null,e.spatialReference,e);return o=>n(z(t,i,s,o))})}async function rt(r,e,t){const{spatialRel:i,geometry:s}=r;if(s){if(!yi(i))throw new R(we,"Unsupported query spatial relationship",{query:r});if(se(s.spatialReference)&&se(t)){if(!Ii(s))throw new R(we,"Unsupported query geometry type",{query:r});if(!Ti(e))throw new R(we,"Unsupported layer geometry type",{query:r});if(r.outSR)return ee(r.geometry&&r.geometry.spatialReference,r.outSR)}}}function at(r){if(ne(r))return!0;if(pe(r)){for(const e of r.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}let me=class extends _e{constructor(){super(...arguments),this._tasks=new Array,this.running=!1}get length(){return this._tasks.length}destroy(){this.cancelAll()}runTask(r){for(;!r.done&&this._process(r);)r.madeProgress()}push(r,e,t){return this.running=!0,new Promise((i,s)=>this._tasks.push(new nt(i,s,r,e,t)))}unshift(r,e,t){return this.running=!0,new Promise((i,s)=>this._tasks.unshift(new nt(i,s,r,e,t)))}_process(r){if(this._tasks.length===0)return!1;const e=this._tasks.shift();try{const t=_t(e.signal);if(t&&!e.abortCallback)e.reject(fe());else{const i=t?e.abortCallback(fe()):e.callback(r);es(i)?i.then(e.resolve,e.reject):e.resolve(i)}}catch(t){e.reject(t)}return this.running=this._tasks.length>0,!0}cancelAll(){const r=fe();for(const e of this._tasks)if(e.abortCallback){const t=e.abortCallback(r);e.resolve(t)}else e.reject(r);this._tasks.length=0,this.running=!1}};$([j()],me.prototype,"running",void 0),me=$([ge("esri.layers.support.PromiseQueue")],me);class nt{constructor(e,t,i,s,a){this.resolve=e,this.reject=t,this.callback=i,this.signal=s,this.abortCallback=a}}let ae=class extends _e{constructor(){super(...arguments),this.SCHEDULER_LOG_SLOW_TASKS=!1,this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES=!1}};$([j()],ae.prototype,"SCHEDULER_LOG_SLOW_TASKS",void 0),$([j()],ae.prototype,"FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES",void 0),ae=$([ge("esri.views.support.DebugFlags")],ae);const Si=new ae,xi=ts.getLogger("esri.views.support.Scheduler");var I;(function(r){r.RESOURCE_CONTROLLER="schedule",r.SLIDE="slide",r.STREAM_DATA_LOADER="stream loader",r.ELEVATION_QUERY="elevation query",r.TERRAIN_SURFACE="terrain",r.SURFACE_GEOMETRY_UPDATES="surface geometry updates",r.GRAPHICS_CORE="Graphics3D",r.I3S_CONTROLLER="I3S",r.POINT_CLOUD_LAYER="point cloud",r.FEATURE_TILE_FETCHER="feature fetcher",r.OVERLAY="overlay",r.STAGE="stage",r.GRAPHICS_DECONFLICTOR="graphics deconflictor",r.FILTER_VISIBILITY="Graphics3D filter visibility",r.SCALE_VISIBILITY="Graphics3D scale visibility",r.FRUSTUM_VISIBILITY="Graphics3D frustum visibility",r.POINT_OF_INTEREST_FREQUENT="POI frequent",r.POINT_OF_INTEREST_INFREQUENT="POI infrequent",r.LABELER="labeler",r.FEATURE_QUERY_ENGINE="feature query",r.FEATURE_TILE_TREE="feature tile tree",r.FEATURE_TILE_TREE_ACTIVE="fast feature tile tree",r.ELEVATION_ALIGNMENT="elevation alignment",r.TEXT_TEXTURE_ATLAS="text texture atlas",r.TEXTURE_UNLOAD="texture unload",r.LINE_OF_SIGHT_TOOL="line of sight tool",r.LINE_OF_SIGHT_TOOL_INTERACTIVE="interactive line of sight tool",r.ELEVATION_PROFILE="elevation profile",r.SNAPPING="snapping",r.SHADOW_ACCUMULATOR="shadow accumulator",r.CLOUDS_GENERATOR="cloud generator",r[r.TEST_PRIO=1]="TEST_PRIO"})(I||(I={}));const G=0,ot=new Map([[I.RESOURCE_CONTROLLER,G],[I.SLIDE,G],[I.STREAM_DATA_LOADER,G],[I.ELEVATION_QUERY,G],[I.TERRAIN_SURFACE,1],[I.SURFACE_GEOMETRY_UPDATES,1],[I.GRAPHICS_CORE,2],[I.I3S_CONTROLLER,2],[I.POINT_CLOUD_LAYER,2],[I.FEATURE_TILE_FETCHER,2],[I.OVERLAY,4],[I.STAGE,4],[I.GRAPHICS_DECONFLICTOR,4],[I.FILTER_VISIBILITY,4],[I.SCALE_VISIBILITY,4],[I.FRUSTUM_VISIBILITY,4],[I.POINT_OF_INTEREST_FREQUENT,6],[I.POINT_OF_INTEREST_INFREQUENT,30],[I.LABELER,8],[I.FEATURE_QUERY_ENGINE,8],[I.FEATURE_TILE_TREE,16],[I.FEATURE_TILE_TREE_ACTIVE,G],[I.ELEVATION_ALIGNMENT,12],[I.TEXT_TEXTURE_ATLAS,12],[I.CLOUDS_GENERATOR,12],[I.TEXTURE_UNLOAD,12],[I.LINE_OF_SIGHT_TOOL,16],[I.LINE_OF_SIGHT_TOOL_INTERACTIVE,G],[I.SNAPPING,G],[I.SHADOW_ACCUMULATOR,30]]);function ut(r){return ot.has(r)?ot.get(r):typeof r=="number"?r:1}var b;(function(r){r[r.ANIMATING=0]="ANIMATING",r[r.INTERACTING=1]="INTERACTING",r[r.IDLE=2]="IDLE"})(b||(b={}));const lt=P(6.5),ct=P(1),Ri=P(30),ht=P(1e3/30),dt=P(100),ft=.9;var Ce,B;(function(r){let e=class extends _e{constructor(s){super(s),this.updating=!0,this._microTaskQueued=!1,this.performanceInfo={total:new Te("total"),tasks:new Map},this._frameTaskTimes=new Map,this._budget=null,this._state=b.INTERACTING,this._tasks=new Ee,this._runQueue=new Ee,this._load=0,this._idleStateCallbacks=new Ee,this._idleUpdatesStartFired=!1,this._maxReschedule=he,this._forceTask=!1,this._debug=!1,this._debugHandle=ss(()=>Si.SCHEDULER_LOG_SLOW_TASKS,o=>this._debug=o,is),this._budget=new i(s.nowFunc);for(const o of Object.keys(I))this.performanceInfo.tasks.set(I[o],new Te(I[o]));let a;const n=this;this._test={get state(){return rs(a,n._state)},set state(o){a=o},FRAME_SAFETY_BUDGET:lt,INTERACTING_BUDGET:ht,IDLE_BUDGET:dt,get budget(){return n._budget.budget},usedBudget:0,setBudget:o=>n._budget=o,updateTask:o=>this._updateTask(o),getState:o=>this._getState(o),getRuntime:o=>this._getRuntime(o),frameTaskTimes:this._frameTaskTimes,resetRuntimes:()=>this._resetRuntimes(),getRunning:()=>this._getRunning()}}destroy(){this._tasks.toArray().forEach(s=>s.remove()),this._tasks.clear(),be(this._debugHandle),this._microTaskQueued=!1,this.updating=!1}activate(){this._budget.done||this._microTaskQueued||(this._microTaskQueued=!0,queueMicrotask(()=>{this._microTaskQueued&&(this._microTaskQueued=!1,this._budget.done||(this._maxReschedule=he,this._schedule(),this.frame()))}))}registerTask(s,a){const n=ut(s),o=new t(this,s,a,n);return this._tasks.push(o),this.performanceInfo.tasks.has(s)||this.performanceInfo.tasks.set(s,new Te(s)),o}registerIdleStateCallbacks(s,a){const n={idleBegin:s,idleEnd:a};this._idleStateCallbacks.push(n),this.state===b.IDLE&&this._idleUpdatesStartFired&&n.idleBegin();const o=this;return{remove:()=>this._removeIdleStateCallbacks(n),set idleBegin(u){o._idleUpdatesStartFired&&(n.idleEnd(),o._state===b.IDLE&&u()),n.idleBegin=u},set idleEnd(u){n.idleEnd=u}}}get now(){return this.nowFunc()}get load(){return this._load}set state(s){this._state!==s&&(this._state=s,this.state!==b.IDLE&&this._idleUpdatesStartFired&&(this._idleUpdatesStartFired=!1,this._idleStateCallbacks.forAll(a=>a.idleEnd())))}get state(){return N(this._test.state)?this._state:this._test.state}updateBudget(s){this._test.usedBudget=0;let a=lt,n=s.frameDuration,o=ct;switch(this.state){case b.IDLE:a=P(0),n=P(Math.max(dt,s.frameDuration)),o=Ri;break;case b.INTERACTING:n=P(Math.max(ht,s.frameDuration));case b.ANIMATING:}return n=P(n-s.elapsedFrameTime-a),this.state!==b.IDLE&&n<ct&&!this._forceTask?(this._forceTask=!0,!1):(n=P(Math.max(n,o)),this._budget.reset(n,this.state),this._maxReschedule=he,this._updateLoad(),this._schedule())}frame(){switch(this._forceTask=!1,this._microTaskQueued=!1,this.state){case b.IDLE:this._idleUpdatesStartFired||(this._idleUpdatesStartFired=!0,this._idleStateCallbacks.forAll(s=>s.idleBegin())),this._runIdle();break;case b.INTERACTING:this._runInteracting();break;default:this._runAnimating()}this._test.usedBudget=this._budget.elapsed}stopFrame(){this._budget.reset(P(0),this._state),this._budget.madeProgress()}_removeIdleStateCallbacks(s){this._idleUpdatesStartFired&&s.idleEnd(),this._idleStateCallbacks.removeUnordered(s)}removeTask(s){this._tasks.removeUnordered(s),this._runQueue.removeUnordered(s)}_updateTask(s){this._tasks.forAll(a=>{a.name===s&&a.setPriority(s)})}_getState(s){if(this._runQueue.some(n=>n.name===s))return B.SCHEDULED;let a=B.IDLE;return this._tasks.forAll(n=>{n.name===s&&n.needsUpdate&&(n.schedulePriority<=1?a=B.READY:a!==B.READY&&(a=B.WAITING))}),a}_getRuntime(s){let a=0;return this._tasks.forAll(n=>{n.name===s&&(a+=n.runtime)}),a}_resetRuntimes(){this._tasks.forAll(s=>s.runtime=0)}_getRunning(){const s=new Map;if(this._tasks.forAll(n=>{n.needsUpdate&&s.set(n.name,(s.get(n.name)||0)+1)}),s.size===0)return null;let a="";return s.forEach((n,o)=>{a+=n>1?` ${n}x ${o}`:` ${o}`}),a}_runIdle(){this._run()}_runInteracting(){this._run()}_runAnimating(){this._run()}_updateLoad(){const s=this._tasks.reduce((a,n)=>n.needsUpdate?++a:a,0);this._load=this._load*ft+s*(1-ft)}_schedule(){if(this._maxReschedule<=0)return!1;for(this._runQueue.filterInPlace(s=>!!s.needsUpdate||(s.schedulePriority=s.basePriority,!1)),this._tasks.forAll(s=>{s.basePriority===G&&s.needsUpdate&&!this._runQueue.some(a=>a===s)&&this._runQueue.unshift(s)});this._runQueue.length===0;){let s=!1,a=0;if(this._tasks.forAll(n=>{n.needsUpdate&&n.schedulePriority!==0&&n.basePriority!==G&&(s=!0,a=Math.max(a,n.basePriority),n.schedulePriority===1?(n.schedulePriority=0,this._runQueue.push(n)):--n.schedulePriority)}),!s)return this.updating=!1,!1;this._maxReschedule===he&&(this._maxReschedule=a),--this._maxReschedule}return this.updating=!0,!0}_run(){const s=this._budget.now();this._startFrameTaskTimes();do for(;this._runQueue.length>0;){const a=this._budget.now(),n=this._runQueue.pop();this._budget.resetProgress();try{n.task.runTask(this._budget)}catch(u){xi.error(`Exception in task "${n.name}"`,u)}n.schedulePriority=n.basePriority;const o=this._budget.now()-a;if(n.runtime+=o,this._frameTaskTimes.set(n.priority,this._frameTaskTimes.get(n.priority)+o),this._debug&&this._budget.elapsed>2*this._budget.budget&&console.log("Task",n.name,"used",this._budget.elapsed,"of max",this._budget.budget,"ms"),this._budget.remaining<=0)return this.updating=this._tasks.some(u=>u.needsUpdate),void this._recordFrameTaskTimes(this._budget.now()-s)}while(this._schedule());this.updating=this._tasks.some(a=>a.needsUpdate),this._recordFrameTaskTimes(this._budget.now()-s)}_startFrameTaskTimes(){for(const s of Object.keys(I))this._frameTaskTimes.set(I[s],0)}_recordFrameTaskTimes(s){this._frameTaskTimes.forEach((a,n)=>this.performanceInfo.tasks.get(n).record(a)),this.performanceInfo.total.record(s)}get test(){return this._test}};$([j()],e.prototype,"updating",void 0),$([j()],e.prototype,"nowFunc",void 0),e=$([ge("esri.views.support.Scheduler")],e),r.Scheduler=e;let t=class extends _e{constructor(s,a,n,o){super({}),this._scheduler=s,this.name=a,this._basePriority=o,this.runtime=0,this._queue=new me,this._handles=new as,this.schedulePriority=this._basePriority,this.task=v(n)?n:this._queue,this._handles.add(ns(()=>this.task.running,()=>s.activate()))}get updating(){return this._queue.running}normalizeCtorArgs(){return{}}remove(){this.processQueue(ye),this._scheduler.removeTask(this),this.schedule=mt.schedule,this.reschedule=mt.reschedule,this._handles.destroy()}get basePriority(){return this._basePriority}setPriority(s){this.name=s;const a=ut(s);this._basePriority!==G&&this.schedulePriority===0||(this.schedulePriority=a),this._basePriority=a}get priority(){return this.name}set priority(s){this.setPriority(s)}get needsUpdate(){return this.updating||this.task.running}schedule(s,a,n){return this._queue.push(s,a,n)}reschedule(s,a,n){return this._queue.unshift(s,a,n)}processQueue(s){this._queue.runTask(s)}};$([j({constructOnly:!0})],t.prototype,"task",void 0),$([j({readOnly:!0})],t.prototype,"updating",null),t=$([ge("esri.views.support.SchedulerTask")],t);class i{constructor(a){this.now=a,this._begin=0,this._budget=0,this._state=b.IDLE,this._didWork=!1,this._enabled=!0}run(a){return!this.done&&(a()===!0&&(this._didWork=!0),!0)}get done(){return this._didWork&&this.elapsed>=this._budget&&this._enabled}get budget(){return this._budget}madeProgress(){this._didWork=!0}get state(){return this._state}get enabled(){return this._enabled}set enabled(a){this._enabled=a}reset(a,n){this._begin=this.now(),this._budget=a,this._state=n,this._didWork=!1}get remaining(){return Math.max(this._budget-this.elapsed,0)}get elapsed(){return this.now()-this._begin}resetProgress(){this._didWork=!1}get hasProgressed(){return this._didWork}}r.Budget=i})(Ce||(Ce={})),function(r){r.SCHEDULED="s",r.READY="r",r.WAITING="w",r.IDLE="i"}(B||(B={}));const ye=(()=>{const r=new Ce.Budget(()=>performance.now());return r.enabled=!1,r})();class wi{remove(){}processQueue(){}schedule(e,t,i){try{if(_t(t)){const s=fe();return i?Promise.resolve(i(s)):Promise.reject(s)}return os(e(ye))}catch(s){return Promise.reject(s)}}reschedule(e,t,i){return this.schedule(e,t,i)}}const mt=new wi,he=Number.MAX_SAFE_INTEGER;function Fi(r){return r.every(e=>e.statisticType!=="exceedslimit")}const V="feature-store:unsupported-query",de=new Set,Ai=new us(2e6);let bi=0;class Yi{constructor(e){this.capabilities={query:Is},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new ls(bi+++"$$",Ai)),this.fieldsIndex=new cs(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=be(this._frameTask),this.clearCache(),Ye(this._geometryQueryCache),this._changeHandle=be(this._changeHandle),Ye(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:te(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=ei(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let i,s=X(e);try{s=await this._schedule(()=>J(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t)}catch(a){if(a!==L)throw a;i=new A([],null,this)}return i.createQueryResponse(s)}async executeQueryForCount(e={},t){let i=X(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule(()=>J(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t);let s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t);return s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t),s.createQueryResponseForCount(i)}catch(s){if(s!==L)throw s;return 0}}async executeQueryForExtent(e={},t){let i,s=X(e);const a=s.outSR;try{s=await this._schedule(()=>J(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),s.returnGeometry=!0,s.returnCentroid=!1,s.outSR=null,i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t);const n=i.size;if(!n)return{count:n,extent:null};hs(O,ds),this.featureStore.forEachBounds(i.items,l=>fs(O,l),Ni);const o={xmin:O[0],ymin:O[1],xmax:O[3],ymax:O[4],spatialReference:te(this.spatialReference)};this.hasZ&&isFinite(O[2])&&isFinite(O[5])&&(o.zmin=O[2],o.zmax=O[5]);const u=M(o,i.spatialReference,a);if(u.spatialReference=te(a||this.spatialReference),u.xmax-u.xmin==0){const l=Se(u.spatialReference);u.xmin-=l,u.xmax+=l}if(u.ymax-u.ymin==0){const l=Se(u.spatialReference);u.ymin-=l,u.ymax+=l}if(this.hasZ&&u.zmin!=null&&u.zmax!=null&&u.zmax-u.zmin==0){const l=Se(u.spatialReference);u.zmin-=l,u.zmax+=l}return{count:n,extent:u}}catch(n){if(n===L)return{count:0,extent:null};throw n}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then(i=>Array.from(i))}async executeQueryForIdSet(e={},t){let i,s=X(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule(()=>J(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t);const a=i.items,n=new Set;return await this._reschedule(()=>{for(const o of a)n.add(i.featureAdapter.getObjectId(o))},t),n}catch(a){if(a===L)return new Set;throw a}}async executeQueryForSnapping(e,t){const{point:i,distance:s,types:a}=e;if(a===ue.NONE)return{candidates:[]};const n=await this._reschedule(()=>this._checkQuerySupport(e.query),t),o=!Y(i.spatialReference,this.spatialReference);o&&await ee(i.spatialReference,this.spatialReference);const u=typeof s=="number"?s:s.x,l=typeof s=="number"?s:s.y,c={xmin:i.x-u,xmax:i.x+u,ymin:i.y-l,ymax:i.y+l,spatialReference:i.spatialReference},f=o?M(c,this.spatialReference):c;if(!f)return{candidates:[]};const m=(await Ne(Ae(i),null,{signal:t}))[0],h=(await Ne(Ae(f),null,{signal:t}))[0];if(N(m)||N(h))return{candidates:[]};let d=new A(this._searchFeatures(this._getQueryBBoxes(h.toJSON())),null,this);d=await this._reschedule(()=>d.executeObjectIdsQuery(n),t),d=await this._reschedule(()=>d.executeTimeQuery(n),t),d=await this._reschedule(()=>d.executeAttributesQuery(n),t);const _=m.toJSON(),x=o?M(_,this.spatialReference):_,E=o?Math.max(f.xmax-f.xmin,f.ymax-f.ymin)/2:s;return d.createSnappingResponse(Ie(re({},e),{point:x,distance:E}),i.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new R(V,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let i,s=X(e);try{s=await this._schedule(()=>J(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t),i=await this._reschedule(()=>i.filterLatest(),t)}catch(a){if(a!==L)throw a;i=new A([],null,this)}return i.createQueryResponse(s)}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:a,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:a,valueExpression:n},i)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,valueExpression:a},i)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:a,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:a,valueExpression:n},i)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:a,valueExpression:n}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:a,valueExpression:n},i)).createHistogramResponse(e,t)}async _schedule(e,t){return v(this._frameTask)?this._frameTask.schedule(e,t):e(ye)}async _reschedule(e,t){return v(this._frameTask)?this._frameTask.reschedule(e,t):e(ye)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach(t=>e.push(t)),this._allItems=new A(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:i,outSR:s,spatialRel:a,returnGeometry:n,returnCentroid:o}=e,u=this.featureStore.featureSpatialReference,l=i&&u&&u!==i.spatialReference?M(i,u):i,c=n||o,f=se(s)&&!Y(this.spatialReference,s),m=this._geometryQueryCache?f&&c?JSON.stringify({originalFilterGeometry:i,spatialRelationship:a,outSpatialReference:s}):JSON.stringify({originalFilterGeometry:i,spatialRelationship:a}):null;if(m){const p=this._geometryQueryCache.get(m);if(!ms(p))return p}const h=async p=>{if(f&&c){const y=await p.project(s);return m&&this._geometryQueryCache.put(m,y,y.size||1),y}return m&&this._geometryQueryCache.put(m,p,p.size||1),p};if(!l)return h(this._getAll());const d=this.featureAdapter;if(a==="esriSpatialRelDisjoint"){const p=this._searchFeatures(this._getQueryBBoxes(i));if(!p.length)return h(this._getAll());let y,T;const g=new Set;for(const w of p)g.add(d.getObjectId(w));await this._reschedule(()=>{let w=0;y=new Array(g.size),this.featureStore.forEach(F=>y[w++]=F),T=g},t);const S=await this._reschedule(async()=>{const w=await it(a,l,this.geometryType,this.hasZ,this.hasM),F=q=>!T.has(d.getObjectId(q))||w(d.getGeometry(q));return new A(await this._runSpatialFilter(y,F,t),i,this)},t);return h(S)}const _=this._searchFeatures(this._getQueryBBoxes(i));if(!_.length){const p=new A([],i,this);return m&&this._geometryQueryCache.put(m,p,p.size||1),p}if(this._canExecuteSoloPass(l,e))return h(new A(_,i,this));const x=await it(a,l,this.geometryType,this.hasZ,this.hasM),E=await this._runSpatialFilter(_,p=>x(d.getGeometry(p)),t);return h(new A(E,i,this))}async _runSpatialFilter(e,t,i){if(!t)return e;if(N(this._frameTask))return e.filter(o=>t(o));let s=0;const a=new Array,n=async o=>{for(;s<e.length;){const u=e[s++];t(u)&&(a.push(u),o.madeProgress()),o.done&&await this._reschedule(l=>n(l),i)}};return this._reschedule(o=>n(o),i).then(()=>a)}_canExecuteSoloPass(e,t){const{geometryType:i}=this,{spatialRel:s}=t;return at(e)&&(s==="esriSpatialRelEnvelopeIntersects"||i==="esriGeometryPoint"&&(s==="esriSpatialRelIntersects"||s==="esriSpatialRelContains"||s==="esriSpatialRelWithin"))}_getQueryBBoxes(e){if(at(e)){if(ne(e))return[Ze(e.xmin,e.ymin,e.xmax,e.ymax)];if(pe(e))return e.rings.map(t=>Ze(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[ps(gs(),e)]}_searchFeatures(e){for(const s of e)this.featureStore.forEachInBounds(s,a=>{de.add(a)});const t=new Array(de.size);let i=0;return de.forEach(s=>t[i++]=s),de.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new R(V,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),rt(e,this.geometryType,this.spatialReference),ee(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:i}=await gt();t=i.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new R(V,"params should have at least a field or valueExpression",{params:e});D(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new R(V,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),rt(e,this.geometryType,this.spatialReference),ee(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:i,returnDistinctValues:s,outStatistics:a}=e,n=a?a.map(o=>o.outStatisticFieldName&&o.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(i&&i.length>0){const o=" asc",u=" desc",l=i.map(c=>{const f=c.toLowerCase();return f.indexOf(o)>-1?f.split(o)[0]:f.indexOf(u)>-1?f.split(u)[0]:c}).filter(c=>n.indexOf(c)===-1);D(this.fieldsIndex,l,"orderByFields contains missing fields")}if(t&&t.length>0)D(this.fieldsIndex,t,"outFields contains missing fields");else if(s)throw new R(V,"outFields should be specified for returnDistinctValues",{query:e});Ys(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:s}=e,a=i&&i.length,n=t&&t.length;if(s){if(!a||!n)throw new R(V,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});Zs(this.fieldsIndex,s,t)}if(n){if(!Fi(t))return;const o=t.map(u=>u.onStatisticField).filter(Boolean);D(this.fieldsIndex,o,"onStatisticFields contains missing fields"),a&&D(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const u of t){const{onStatisticField:l,statisticType:c}=u;if((c==="percentile_disc"||c==="percentile_cont")&&"statisticParameters"in u){const{statisticParameters:f}=u;if(!f)throw new R(V,"statisticParamters should be set for percentile type",{definition:u,query:e})}else if(c!=="count"&&l&&Ws(l,this.fieldsIndex))throw new R(V,"outStatistics contains non-numeric fields",{definition:u,query:e})}}}async _getQueryEngineResultForStats(e={},t,i){let s;e=X(e);try{e=await this._schedule(()=>J(e,this.definitionExpression,this.spatialReference),i),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),i),s=await this._reschedule(()=>this._executeGeometryQuery(e,i),i),s=await this._reschedule(()=>s.executeAggregateIdsQuery(e),i),s=await this._reschedule(()=>s.executeObjectIdsQuery(e),i),s=await this._reschedule(()=>s.executeTimeQuery(e),i),s=await this._reschedule(()=>s.executeAttributesQuery(e),i)}catch(a){if(a!==L)throw a;s=new A([],null,this)}return s}}const Ni=yt(),O=yt();export{Bi as B,ji as C,Yi as V,oi as Z,it as a,zi as e,ee as f,M as g,ti as n,Ui as q,et as s,qi as v};
